// Generated by CoffeeScript 1.6.3
(function() {
  var URI, URICollection, URLCOUNT, URL_INDICES, add, assert, isURI, urlList, _, _i, _ref, _ref1, _results;

  assert = require("better-assert");

  _ = require("underscore");

  _ref = require("../index.js"), URICollection = _ref.URICollection, isURI = _ref.isURI;

  URI = require("URIjs");

  urlList = ["http://www.google.com/foo", "http://www.bar.org", "http://www.cnn.com/theNewsIGuess", "http://www.foo.com/index.html"];

  URLCOUNT = urlList.length;

  URL_INDICES = (function() {
    _results = [];
    for (var _i = 0, _ref1 = URLCOUNT - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; 0 <= _ref1 ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this);

  add = function(x, y) {
    return x + y;
  };

  describe("URICollection", function() {
    var collection, _urls;
    _urls = _.clone(urlList);
    collection = {};
    beforeEach(function() {
      return collection = new URICollection(_urls);
    });
    describe("map", function() {
      it("should return a new URICollection when a map operation returns URIjs instances.", function() {
        var _mapped;
        _mapped = collection.map(function(uri) {
          return uri.domain("jabber.net");
        });
        return assert(_mapped instanceof URICollection);
      });
      it("should return a vanilla array when a map operation returns results other than URIjs instances.", function() {
        var _mapped;
        _mapped = collection.map(function(uri) {
          return uri.domain();
        });
        return assert(_mapped instanceof Array);
      });
      it("should not mutate URIjs instances in the original collection", function() {
        var copy, i, _j, _len, _mapped, _results1;
        copy = collection.clone();
        _mapped = copy.map(function(uri) {
          return uri.domain("changed.net");
        });
        _results1 = [];
        for (_j = 0, _len = URL_INDICES.length; _j < _len; _j++) {
          i = URL_INDICES[_j];
          assert(copy.stringAt(i) === collection.stringAt(i));
          _results1.push(assert(_mapped.stringAt(i) !== collection.stringAt(i)));
        }
        return _results1;
      });
      return it("should produce the same result as a series of individual URIjs instance manipulations.", function() {
        var copy, i, _j, _len, _mapped, _results1;
        copy = collection.clone();
        _mapped = copy.map(function(uri) {
          return uri.domain("changed.net");
        });
        _results1 = [];
        for (_j = 0, _len = URL_INDICES.length; _j < _len; _j++) {
          i = URL_INDICES[_j];
          _results1.push(assert(_mapped.stringAt(i) === collection.at(i).clone().domain("changed.net").toString()));
        }
        return _results1;
      });
    });
    describe("toArray", function() {
      it("should return a vanilla javascript array", function() {
        return assert(collection.toArray() instanceof Array);
      });
      return it("should return *clones* of its internal URIjs instances", function() {
        var fromCollection, i, _j, _len, _results1;
        fromCollection = collection.toArray();
        _results1 = [];
        for (_j = 0, _len = URL_INDICES.length; _j < _len; _j++) {
          i = URL_INDICES[_j];
          assert(fromCollection[i] !== collection.at(i));
          assert(fromCollection[i].toString() === collection.at(i).toString());
          _results1.push(assert(fromCollection[i].domain("other.org").toString() !== collection.at(i).toString()));
        }
        return _results1;
      });
    });
    describe("clone", function() {
      it("should return a new URICollection instance", function() {
        return assert(collection.clone() instanceof URICollection);
      });
      it("should create a copy with the same number of elements", function() {
        return assert(collection.clone().size() === collection.size());
      });
      it("should create a copy with individual URIjs elements cloned themselves", function() {
        var cloned, i, _j, _len, _results1;
        cloned = collection.clone();
        _results1 = [];
        for (_j = 0, _len = URL_INDICES.length; _j < _len; _j++) {
          i = URL_INDICES[_j];
          _results1.push(assert(cloned.at(i) !== collection.at(i)));
        }
        return _results1;
      });
      return it("should create a copy with DEEP-equal elements", function() {
        var cloned, i, _j, _len, _results1;
        cloned = collection.clone();
        _results1 = [];
        for (_j = 0, _len = URL_INDICES.length; _j < _len; _j++) {
          i = URL_INDICES[_j];
          _results1.push(assert(cloned.at(i).toString() === collection.at(i).toString()));
        }
        return _results1;
      });
    });
    describe("each", function() {
      it("should return a new URI collection, even without an iterator return value", function() {
        var eachified;
        eachified = collection.each(function(x) {
          return x;
        });
        assert(eachified instanceof URICollection);
        return assert(eachified.size() === collection.size());
      });
      it("should not mutate URIjs instances in the original collection", function() {
        var copy, eachified, i, _j, _len, _results1;
        copy = collection.clone();
        eachified = copy.each(function(uri) {
          return uri.domain("changed.net");
        });
        _results1 = [];
        for (_j = 0, _len = URL_INDICES.length; _j < _len; _j++) {
          i = URL_INDICES[_j];
          assert(copy.stringAt(i) === collection.stringAt(i));
          _results1.push(assert(eachified.stringAt(0) !== collection.stringAt(0)));
        }
        return _results1;
      });
      return it("should produce the same result as a series of individual URIjs instance manipulations.", function() {
        var copy, eachified, i, _j, _len, _results1;
        copy = collection.clone();
        eachified = copy.each(function(uri) {
          return uri.domain("changed.net");
        });
        _results1 = [];
        for (_j = 0, _len = URL_INDICES.length; _j < _len; _j++) {
          i = URL_INDICES[_j];
          _results1.push(assert(eachified.stringAt(i) === collection.at(i).clone().domain("changed.net").toString()));
        }
        return _results1;
      });
    });
    describe("pluck", function() {
      it("should extract the given property from each URI instance.", function() {
        var i, plucked, _j, _len, _results1;
        plucked = collection.pluck("domain");
        _results1 = [];
        for (_j = 0, _len = URL_INDICES.length; _j < _len; _j++) {
          i = URL_INDICES[_j];
          _results1.push(assert(plucked[i] === collection.at(i).domain()));
        }
        return _results1;
      });
      return it("should return an array with length equal to that of the collection.", function() {
        var eachified, plucked;
        plucked = collection.pluck("domain");
        assert(plucked.length === collection.size());
        eachified = collection.each(function(x) {
          return x;
        });
        assert(eachified instanceof URICollection);
        return assert(eachified.size() === collection.size());
      });
    });
    return describe("invoke", function() {
      it("should return the same number of results as there are elements in the original collection.", function() {
        var invoked;
        invoked = collection.invoke("domain");
        return assert(invoked.length === collection.size());
      });
      it("should return a vanilla array when passed a method name but no additional parameters.", function() {
        var invoked;
        invoked = collection.invoke("domain");
        return assert(invoked instanceof Array);
      });
      it("should return a new URICollection when passed a method name and additional parameters.", function() {
        var invoked;
        invoked = collection.invoke("domain", "catsofcourse.net");
        return assert(invoked instanceof URICollection);
      });
      it("when called with only a method name, should return the same array of results returned from manual iteration + no-arg invocation over a plain array of URIjs instances.", function() {
        var i, invoked, plainResults, vanilla, _j, _ref2, _results1;
        invoked = collection.invoke("domain");
        vanilla = collection.toArray();
        plainResults = _.map(vanilla, function(oneURI) {
          return oneURI.domain();
        });
        assert(invoked.length === plainResults.length);
        _results1 = [];
        for (i = _j = 0, _ref2 = invoked.length - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
          _results1.push(assert(invoked[i] === plainResults[i]));
        }
        return _results1;
      });
      return it("when called with a method and additional parameters, should return a collection of URIjs instances deep-equal to the manual-iteration equivalent.", function() {
        var domainArg, i, invoked, plainResults, vanilla, _j, _ref2, _results1;
        domainArg = "surpriseMoreCats.net";
        invoked = collection.invoke("domain", domainArg);
        vanilla = collection.toArray();
        plainResults = _.map(vanilla, function(oneURI) {
          return oneURI.domain(domainArg);
        });
        assert(invoked.size() === plainResults.length);
        _results1 = [];
        for (i = _j = 0, _ref2 = invoked.length - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
          _results1.push(assert(invoked.at(i).toString() === plainResults[i].toString()));
        }
        return _results1;
      });
    });
  });

}).call(this);
